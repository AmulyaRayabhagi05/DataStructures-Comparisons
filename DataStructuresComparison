import java.util.*;
import java.io.*;

public class DataStructuresComparison {
    public static void main(String[] args) {
        // Test parameters
        int[] dataSizes = {1000, 10000, 100000};
        int numTrials = 5; // Run multiple trials and average the results for more accuracy
        
        // Results storage
        long[][][] insertionTimes = new long[4][3][numTrials]; // [data structure][data size][trial]
        long[][][] searchTimes = new long[4][3][numTrials];
        long[][][] deletionTimes = new long[4][3][numTrials];
        
        long[][] memoryUsage = new long[4][3]; // [data structure][data size]
        
        // Run experiments
        for (int sizeIndex = 0; sizeIndex < dataSizes.length; sizeIndex++) {
            int size = dataSizes[sizeIndex];
            System.out.println("Testing with " + size + " elements...");
            
            for (int trial = 0; trial < numTrials; trial++) {
                System.out.println("  Trial " + (trial + 1) + "...");
                
                // Generate random elements
                Integer[] elements = generateRandomElements(size);
                Integer[] lookupElements = new Integer[size / 10]; // Use 10% of elements for lookup
                for (int i = 0; i < lookupElements.length; i++) {
                    lookupElements[i] = elements[new Random().nextInt(elements.length)];
                }
                
                Integer[] deleteElements = new Integer[size / 10]; // Use 10% of elements for deletion
                for (int i = 0; i < deleteElements.length; i++) {
                    deleteElements[i] = elements[new Random().nextInt(elements.length)];
                }
                
                // Test AVL Tree
                testAVLTree(elements, lookupElements, deleteElements, insertionTimes, searchTimes, deletionTimes, memoryUsage, sizeIndex, trial);
                
                // Test Splay Tree
                testSplayTree(elements, lookupElements, deleteElements, insertionTimes, searchTimes, deletionTimes, memoryUsage, sizeIndex, trial);
                
                // Test Hash Table (Chaining)
                testHashTableChaining(elements, lookupElements, deleteElements, insertionTimes, searchTimes, deletionTimes, memoryUsage, sizeIndex, trial);
                
                // Test Hash Table (Quadratic Probing)
                testHashTableQuadratic(elements, lookupElements, deleteElements, insertionTimes, searchTimes, deletionTimes, memoryUsage, sizeIndex, trial);
            }
        }
        
        // Display results
        displayResults(dataSizes, numTrials, insertionTimes, searchTimes, deletionTimes, memoryUsage);
    }
    
    private static Integer[] generateRandomElements(int size) {
        Random random = new Random();
        Set<Integer> uniqueElements = new HashSet<>();
        
        while (uniqueElements.size() < size) {
            uniqueElements.add(random.nextInt(size * 10)); // Larger range to avoid too many duplicates
        }
        
        return uniqueElements.toArray(new Integer[0]);
    }
    
    private static void testAVLTree(Integer[] elements, Integer[] lookupElements, Integer[] deleteElements,
                                   long[][][] insertionTimes, long[][][] searchTimes, long[][][] deletionTimes,
                                   long[][] memoryUsage, int sizeIndex, int trial) {
        System.gc(); // Suggest garbage collection before test
        
        AVLTree<Integer> avlTree = new AVLTree<>();
        
        // Measure insertion time
        long startMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        long startTime = System.nanoTime();
        
        for (Integer element : elements) {
            avlTree.insert(element);
        }
        
        long endTime = System.nanoTime();
        long endMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        
        insertionTimes[0][sizeIndex][trial] = (endTime - startTime) / 1_000_000; // Convert to milliseconds
        memoryUsage[0][sizeIndex] = endMemory - startMemory;
        
        // Measure search time
        startTime = System.nanoTime();
        
        for (Integer element : lookupElements) {
            avlTree.contains(element);
        }
        
        endTime = System.nanoTime();
        searchTimes[0][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        
        // Measure deletion time
        startTime = System.nanoTime();
        
        for (Integer element : deleteElements) {
            avlTree.delete(element);
        }
        
        endTime = System.nanoTime();
        deletionTimes[0][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
    }
    
    private static void testSplayTree(Integer[] elements, Integer[] lookupElements, Integer[] deleteElements,
                                     long[][][] insertionTimes, long[][][] searchTimes, long[][][] deletionTimes,
                                     long[][] memoryUsage, int sizeIndex, int trial) {
        System.gc(); // Suggest garbage collection before test
        
        SplayTree<Integer> splayTree = new SplayTree<>();
        
        // Measure insertion time
        long startMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        long startTime = System.nanoTime();
        
        for (Integer element : elements) {
            splayTree.insert(element);
        }
        
        long endTime = System.nanoTime();
        long endMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        
        insertionTimes[1][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        memoryUsage[1][sizeIndex] = endMemory - startMemory;
        
        // Measure search time
        startTime = System.nanoTime();
        
        for (Integer element : lookupElements) {
            splayTree.contains(element);
        }
        
        endTime = System.nanoTime();
        searchTimes[1][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        
        // Measure deletion time
        startTime = System.nanoTime();
        
        for (Integer element : deleteElements) {
            splayTree.delete(element);
        }
        
        endTime = System.nanoTime();
        deletionTimes[1][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
    }
    
    private static void testHashTableChaining(Integer[] elements, Integer[] lookupElements, Integer[] deleteElements,
                                            long[][][] insertionTimes, long[][][] searchTimes, long[][][] deletionTimes,
                                            long[][] memoryUsage, int sizeIndex, int trial) {
        System.gc(); // Suggest garbage collection before test
        
        HashTableChaining<Integer> hashTable = new HashTableChaining<>(elements.length * 2); // Use load factor of 0.5
        
        // Measure insertion time
        long startMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        long startTime = System.nanoTime();
        
        for (Integer element : elements) {
            hashTable.insert(element);
        }
        
        long endTime = System.nanoTime();
        long endMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        
        insertionTimes[2][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        memoryUsage[2][sizeIndex] = endMemory - startMemory;
        
        // Measure search time
        startTime = System.nanoTime();
        
        for (Integer element : lookupElements) {
            hashTable.contains(element);
        }
        
        endTime = System.nanoTime();
        searchTimes[2][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        
        // Measure deletion time
        startTime = System.nanoTime();
        
        for (Integer element : deleteElements) {
            hashTable.delete(element);
        }
        
        endTime = System.nanoTime();
        deletionTimes[2][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
    }
    
    private static void testHashTableQuadratic(Integer[] elements, Integer[] lookupElements, Integer[] deleteElements,
                                             long[][][] insertionTimes, long[][][] searchTimes, long[][][] deletionTimes,
                                             long[][] memoryUsage, int sizeIndex, int trial) {
        System.gc(); // Suggest garbage collection before test
        
        HashTableQuadratic<Integer> hashTable = new HashTableQuadratic<>(elements.length * 2); // Use load factor of 0.5
        
        // Measure insertion time
        long startMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        long startTime = System.nanoTime();
        
        for (Integer element : elements) {
            hashTable.insert(element);
        }
        
        long endTime = System.nanoTime();
        long endMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        
        insertionTimes[3][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        memoryUsage[3][sizeIndex] = endMemory - startMemory;
        
        // Measure search time
        startTime = System.nanoTime();
        
        for (Integer element : lookupElements) {
            hashTable.contains(element);
        }
        
        endTime = System.nanoTime();
        searchTimes[3][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
        
        // Measure deletion time
        startTime = System.nanoTime();
        
        for (Integer element : deleteElements) {
            hashTable.delete(element);
        }
        
        endTime = System.nanoTime();
        deletionTimes[3][sizeIndex][trial] = (endTime - startTime) / 1_000_000;
    }
    
    private static void displayResults(int[] dataSizes, int numTrials, 
                                      long[][][] insertionTimes, long[][][] searchTimes, long[][][] deletionTimes,
                                      long[][] memoryUsage) {
        String[] dataStructures = {"AVL Tree", "Splay Tree", "Hash Table (Chaining)", "Hash Table (Quadratic Probing)"};
        
        try {
            // Write results to file
            PrintWriter writer = new PrintWriter(new FileWriter("performance_results.txt"));
            
            // Calculate averages
            double[][] avgInsertionTimes = new double[4][3];
            double[][] avgSearchTimes = new double[4][3];
            double[][] avgDeletionTimes = new double[4][3];
            
            for (int ds = 0; ds < 4; ds++) {
                for (int size = 0; size < 3; size++) {
                    double insertSum = 0, searchSum = 0, deleteSum = 0;
                    for (int trial = 0; trial < numTrials; trial++) {
                        insertSum += insertionTimes[ds][size][trial];
                        searchSum += searchTimes[ds][size][trial];
                        deleteSum += deletionTimes[ds][size][trial];
                    }
                    avgInsertionTimes[ds][size] = insertSum / numTrials;
                    avgSearchTimes[ds][size] = searchSum / numTrials;
                    avgDeletionTimes[ds][size] = deleteSum / numTrials;
                }
            }
            
            // Print insertion results
            writer.println("Insertion Performance Comparison (Time in milliseconds)");
            writer.println("Data Structure\t1,000 Elements\t10,000 Elements\t100,000 Elements");
            for (int ds = 0; ds < 4; ds++) {
                writer.println(dataStructures[ds] + "\t" + 
                               String.format("%.2f", avgInsertionTimes[ds][0]) + "ms\t" + 
                               String.format("%.2f", avgInsertionTimes[ds][1]) + "ms\t" + 
                               String.format("%.2f", avgInsertionTimes[ds][2]) + "ms");
            }
            writer.println();
            
            // Print search results
            writer.println("Search Performance Comparison (Time in milliseconds)");
            writer.println("Data Structure\t1,000 Searches\t10,000 Searches\t100,000 Searches");
            for (int ds = 0; ds < 4; ds++) {
                writer.println(dataStructures[ds] + "\t" + 
                               String.format("%.2f", avgSearchTimes[ds][0]) + "ms\t" + 
                               String.format("%.2f", avgSearchTimes[ds][1]) + "ms\t" + 
                               String.format("%.2f", avgSearchTimes[ds][2]) + "ms");
            }
            writer.println();
            
            // Print deletion results
            writer.println("Deletion Performance Comparison (Time in milliseconds)");
            writer.println("Data Structure\t1,000 Deletions\t10,000 Deletions\t100,000 Deletions");
            for (int ds = 0; ds < 4; ds++) {
                writer.println(dataStructures[ds] + "\t" + 
                               String.format("%.2f", avgDeletionTimes[ds][0]) + "ms\t" + 
                               String.format("%.2f", avgDeletionTimes[ds][1]) + "ms\t" + 
                               String.format("%.2f", avgDeletionTimes[ds][2]) + "ms");
            }
            writer.println();
            
            // Print memory usage
            writer.println("Memory Usage Comparison (in bytes)");
            writer.println("Data Structure\t1,000 Elements\t10,000 Elements\t100,000 Elements");
            for (int ds = 0; ds < 4; ds++) {
                writer.println(dataStructures[ds] + "\t" + 
                               memoryUsage[ds][0] + "\t" + 
                               memoryUsage[ds][1] + "\t" + 
                               memoryUsage[ds][2]);
            }
            
            writer.close();
            
            // Print to console as well
            System.out.println("\n=== Performance Results ===");
            System.out.println("Results have been written to performance_results.txt");
            
        } catch (IOException e) {
            System.err.println("Error writing results to file: " + e.getMessage());
        }
    }
}

// AVL Tree Implementation
class AVLTree<T extends Comparable<T>> {
    private class Node {
        T data;
        Node left;
        Node right;
        int height;
        
        Node(T data) {
            this.data = data;
            this.height = 1;
        }
    }
    
    private Node root;
    
    public void insert(T data) {
        root = insert(root, data);
    }
    
    private Node insert(Node node, T data) {
        // Perform standard BST insert
        if (node == null) {
            return new Node(data);
        }
        
        int compareResult = data.compareTo(node.data);
        
        if (compareResult < 0) {
            node.left = insert(node.left, data);
        } else if (compareResult > 0) {
            node.right = insert(node.right, data);
        } else {
            // Duplicate keys not allowed
            return node;
        }
        
        // Update height
        node.height = 1 + Math.max(height(node.left), height(node.right));
        
        // Get the balance factor
        int balance = getBalance(node);
        
        // Left Left Case
        if (balance > 1 && data.compareTo(node.left.data) < 0) {
            return rightRotate(node);
        }
        
        // Right Right Case
        if (balance < -1 && data.compareTo(node.right.data) > 0) {
            return leftRotate(node);
        }
        
        // Left Right Case
        if (balance > 1 && data.compareTo(node.left.data) > 0) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        
        // Right Left Case
        if (balance < -1 && data.compareTo(node.right.data) < 0) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
        
        return node;
    }
    
    public void delete(T data) {
        root = delete(root, data);
    }
    
    private Node delete(Node node, T data) {
        // Standard BST delete
        if (node == null) {
            return null;
        }
        
        int compareResult = data.compareTo(node.data);
        
        if (compareResult < 0) {
            node.left = delete(node.left, data);
        } else if (compareResult > 0) {
            node.right = delete(node.right, data);
        } else {
            // Node with only one child or no child
            if (node.left == null) {
                return node.right;
            } else if (node.right == null) {
                return node.left;
            }
            
            // Node with two children: Get the inorder successor (smallest in the right subtree)
            node.data = findMin(node.right).data;
            
            // Delete the inorder successor
            node.right = delete(node.right, node.data);
        }
        
        // If the tree had only one node then return
        if (node == null) {
            return null;
        }
        
        // Update height
        node.height = 1 + Math.max(height(node.left), height(node.right));
        
        // Get the balance factor
        int balance = getBalance(node);
        
        // Left Left Case
        if (balance > 1 && getBalance(node.left) >= 0) {
            return rightRotate(node);
        }
        
        // Left Right Case
        if (balance > 1 && getBalance(node.left) < 0) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        
        // Right Right Case
        if (balance < -1 && getBalance(node.right) <= 0) {
            return leftRotate(node);
        }
        
        // Right Left Case
        if (balance < -1 && getBalance(node.right) > 0) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
        
        return node;
    }
    
    private Node findMin(Node node) {
        Node current = node;
        while (current.left != null) {
            current = current.left;
        }
        return current;
    }
    
    public boolean contains(T data) {
        return contains(root, data);
    }
    
    private boolean contains(Node node, T data) {
        if (node == null) {
            return false;
        }
        
        int compareResult = data.compareTo(node.data);
        
        if (compareResult < 0) {
            return contains(node.left, data);
        } else if (compareResult > 0) {
            return contains(node.right, data);
        } else {
            return true;
        }
    }
    
    private int height(Node node) {
        return node == null ? 0 : node.height;
    }
    
    private int getBalance(Node node) {
        return node == null ? 0 : height(node.left) - height(node.right);
    }
    
    private Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;
        
        // Perform rotation
        x.right = y;
        y.left = T2;
        
        // Update heights
        y.height = 1 + Math.max(height(y.left), height(y.right));
        x.height = 1 + Math.max(height(x.left), height(x.right));
        
        return x;
    }
    
    private Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;
        
        // Perform rotation
        y.left = x;
        x.right = T2;
        
        // Update heights
        x.height = 1 + Math.max(height(x.left), height(x.right));
        y.height = 1 + Math.max(height(y.left), height(y.right));
        
        return y;
    }
}

// Splay Tree Implementation
class SplayTree<T extends Comparable<T>> {
    private class Node {
        T data;
        Node left;
        Node right;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    private Node root;
    
    public void insert(T data) {
        if (root == null) {
            root = new Node(data);
            return;
        }
        
        root = splay(root, data);
        
        int compareResult = data.compareTo(root.data);
        
        if (compareResult == 0) {
            // Duplicate, just return
            return;
        }
        
        Node newNode = new Node(data);
        
        if (compareResult < 0) {
            newNode.right = root;
            newNode.left = root.left;
            root.left = null;
        } else {
            newNode.left = root;
            newNode.right = root.right;
            root.right = null;
        }
        
        root = newNode;
    }
    
    public void delete(T data) {
        if (root == null) return;
        
        root = splay(root, data);
        
        if (data.compareTo(root.data) != 0) {
            // Key not found
            return;
        }
        
        // Key found at root
        if (root.left == null) {
            root = root.right;
        } else {
            Node temp = root.right;
            root = root.left;
            // Find the maximum element in the left subtree
            root = splay(root, data);
            // Link right subtree as the right child of the new root
            root.right = temp;
        }
    }
    
    public boolean contains(T data) {
        if (root == null) return false;
        
        root = splay(root, data);
        return data.compareTo(root.data) == 0;
    }
    
    private Node splay(Node root, T data) {
        if (root == null || data.compareTo(root.data) == 0) {
            return root;
        }
        
        int compareResult = data.compareTo(root.data);
        
        if (compareResult < 0) {
            // Key is in left subtree
            if (root.left == null) {
                return root;
            }
            
            int leftCompare = data.compareTo(root.left.data);
            
            if (leftCompare < 0) {
                // Zig-Zig (left-left)
                root.left.left = splay(root.left.left, data);
                root = rightRotate(root);
            } else if (leftCompare > 0) {
                // Zig-Zag (left-right)
                root.left.right = splay(root.left.right, data);
                if (root.left.right != null) {
                    root.left = leftRotate(root.left);
                }
            }
            
            return (root.left == null) ? root : rightRotate(root);
        } else {
            // Key is in right subtree
            if (root.right == null) {
                return root;
            }
            
            int rightCompare = data.compareTo(root.right.data);
            
            if (rightCompare > 0) {
                // Zag-Zag (right-right)
                root.right.right = splay(root.right.right, data);
                root = leftRotate(root);
            } else if (rightCompare < 0) {
                // Zag-Zig (right-left)
                root.right.left = splay(root.right.left, data);
                if (root.right.left != null) {
                    root.right = rightRotate(root.right);
                }
            }
            
            return (root.right == null) ? root : leftRotate(root);
        }
    }
    
    private Node rightRotate(Node y) {
        Node x = y.left;
        y.left = x.right;
        x.right = y;
        return x;
    }
    
    private Node leftRotate(Node x) {
        Node y = x.right;
        x.right = y.left;
        y.left = x;
        return y;
    }
}

// Hash Table with Chaining
class HashTableChaining<T> {
    private class Node {
        T data;
        Node next;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    private Node[] table;
    private int size;
    private int capacity;
    
    @SuppressWarnings("unchecked")
    public HashTableChaining(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.table = (Node[]) new HashTableChaining.Node[capacity];
    }
    
    public void insert(T data) {
        int index = getIndex(data);
        
        // Check if data already exists
        Node current = table[index];
        while (current != null) {
            if (current.data.equals(data)) {
                return; // Element already exists
            }
            current = current.next;
        }
        
        // Insert at the beginning of the chain
        Node newNode = new Node(data);
        newNode.next = table[index];
        table[index] = newNode;
        size++;
    }
    
    public void delete(T data) {
        int index = getIndex(data);
        
        // Check if the list is empty
        if (table[index] == null) {
            return;
        }
        
        // If the first node is the one to delete
        if (table[index].data.equals(data)) {
            table[index] = table[index].next;
            size--;
            return;
        }
        
        // Search for the node to delete
        Node current = table[index];
        while (current.next != null && !current.next.data.equals(data)) {
            current = current.next;
        }
        
        // If data found, delete it
        if (current.next != null) {
            current.next = current.next.next;
            size--;
        }
    }
    
    public boolean contains(T data) {
        int index = getIndex(data);
        
        Node current = table[index];
        while (current != null) {
            if (current.data.equals(data)) {
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    private int getIndex(T data) {
        // Get positive hash code
        int hashCode = data.hashCode() & 0x7fffffff;
        return hashCode % capacity;
    }
}

// Hash Table with Quadratic Probing
class HashTableQuadratic<T> {
    private enum EntryState { EMPTY, OCCUPIED, DELETED }
    
    private class Entry {
        T data;
        EntryState state;
        
        Entry() {
            this.state = EntryState.EMPTY;
        }
    }
    
    private Entry[] table;
    private int size;
    private int capacity;
    
    private static boolean isPrime(int n) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 == 0 || n % 3 == 0) return false;
        for (int i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) return false;
        }
        return true;
    }
    
    @SuppressWarnings("unchecked")
    public HashTableQuadratic(int capacity) {
        this.capacity = isPrime(capacity) ? capacity : getNextPrime(capacity);
        this.size = 0;
        this.table = (Entry[]) new HashTableQuadratic.Entry[this.capacity];
        for (int i = 0; i < this.capacity; i++) {
            this.table[i] = new Entry();
        }
    }
        private static int getNextPrime(int n) {
        while (true) {
            n++;
            if (isPrime(n)) return n;
        }
    }
        private int getIndex(T data) {
        return (data.hashCode() & 0x7fffffff) % capacity;
    }
    
    public void insert(T data) {
        if (size >= capacity / 2) { // Keep load factor below 0.5
            rehash();
        }
        
        int hash = getIndex(data);
        int i = 0;
        int index;
        
        do {
            index = (hash + i * i) % capacity;
            
            if (table[index].state == EntryState.EMPTY || table[index].state == EntryState.DELETED) {
                table[index].data = data;
                table[index].state = EntryState.OCCUPIED;
                size++;
                return;
            } else if (table[index].data.equals(data)) {
                return; // Element already exists
            }
            
            i++;
        } while (i < capacity);
    }
    
    public void delete(T data) {
        int hash = getIndex(data);
        int i = 0;
        int index;
        
        do {
            index = (hash + i * i) % capacity;
            
            if (table[index].state == EntryState.EMPTY) {
                return; // Element not found
            }
            
            if (table[index].state == EntryState.OCCUPIED && table[index].data.equals(data)) {
                table[index].state = EntryState.DELETED;
                size--;
                return;
            }
            
            i++;
        } while (i < capacity);
    }
    
    public boolean contains(T data) {
        int hash = getIndex(data);
        int i = 0;
        int index;
        
        do {
            index = (hash + i * i) % capacity;
            
            if (table[index].state == EntryState.EMPTY) {
                return false;
            }
            
            if (table[index].state == EntryState.OCCUPIED && table[index].data.equals(data)) {
                return true;
            }
            
            i++;
        } while (i < capacity && table[index].state != EntryState.EMPTY);
        
        return false;
    }
    
    @SuppressWarnings("unchecked")
private void rehash() {
    int oldCapacity = capacity;
    Entry[] oldTable = table;
    
    capacity = getNextPrime(2 * oldCapacity);
    size = 0;
    table = (Entry[]) new HashTableQuadratic.Entry[capacity];
    for (int i = 0; i < capacity; i++) {
        table[i] = new Entry();
    }
    
    for (int i = 0; i < oldCapacity; i++) {
        if (oldTable[i].state == EntryState.OCCUPIED) {
            insert(oldTable[i].data);
        }
    }
}
}
